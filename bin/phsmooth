#!/usr/bin/env python

import sys, os, argparse
import pandas as pd
import numpy  as np

def unwrap(phi):
    for i in np.arange(phi.shape[1]-1)+1:
        a, b = phi[:,i-1], phi[:,i]
        b[b - a >  180] -= 360
        b[b - a < -180] += 360
        phi[:,i] = b
    return phi

def qfit(y1, y2, y3):
    a  =       y1
    b  = (-3.0*y1 + 4.0*y2 - y3) / 2.0
    c  = (     y1 - 2.0*y2 + y3) / 2.0
    return a, b, c

# Argument parsing
parser = argparse.ArgumentParser(description="Smooth phase-cal phases")
parser.add_argument('-f', dest='file', default=None,
                    help="input file")
parser.add_argument('-p', dest='pout', default=None,
                    help="smoothed phase-cal phases")
parser.add_argument('-s', dest='sout', default=None,
                    help="slope of each channel")
parser.add_argument('-d', dest='dout', default=None,
                    help="delay offset within each channel")
parser.add_argument('-c', dest='cout', default=None,
                    help="fourfit control file")
parser.add_argument('-g', dest='gout', default=None,
                    help="graphic output to show the smoothing")
args = parser.parse_args()

# Read args.file or stdin to a Pandas DataFrame
df = pd.read_table(sys.stdin if args.file is None else args.file,
                   header=None, sep='\s+')

# Pull out baselines, unwrap phases, use one-side and mid-point
# methods to esimate slopes
baselines = df[0]
phases    = unwrap(df.iloc[:,1:].values)
slopes    = np.concatenate((np.reshape(phases[:, 1 ] - phases[:,  0], (-1,1)),
                                0.5 * (phases[:, 2:] - phases[:,:-2]),
                            np.reshape(phases[:,-1 ] - phases[:, -2], (-1,1))),
                           axis=1)

# Extra polation
a, b, c = qfit(phases[:,-4], phases[:,-3], phases[:,-2])
phases[:,-1] = a + 3.0*b + 9.0*c # == a + b x +   c x**2 with x == 3
slopes[:,-1] =         b + 6.0*c # ==     b   + 2 c x    with x == 3

# Fitted slope (instead of one-side derivative)
slopes[:,-2] = b + 4.0*c # == b   + 2 c x    with x == 2
a, b, c = qfit(phases[:,0], phases[:,1], phases[:,2])
slopes[:, 0] = b         # == b   + 2 c x    with x == 0

# Plot the smoothing result to args.gout
if args.gout is not None:
    import matplotlib.pyplot as plt
    import matplotlib.cm     as cm # not best practice, but avoid extra
                                   # library when no graph is specified
    cs = cm.rainbow(np.linspace(0,1,len(df)))
    d  = np.array([-0.5,0.5])
    x  = np.arange(32)
    for i, b in baselines.iteritems():
        y = phases[i,:]
        m = slopes[i,:]
        plt.scatter(x, y, color=cs[i], label=b)
        for j in np.arange(32):
            plt.plot(x[j]+d, y[j]+d*m[j], color=cs[i])
    plt.legend()
    if "." in args.gout:
        plt.savefig(args.gout)
    else:
        plt.show()

# Write phase-cal phases to stdout: format is backward compatible
out = pd.DataFrame(data=phases)
out.insert(0, 'baseline', baselines)
if args.pout is None:
    out.to_csv(sys.stdout,
               index=False, header=False, sep=" ", float_format="%.9g")

# Write phase-cal phases to args.pout
phases = pd.DataFrame(data=phases)
phases.insert(0, 'site', baselines.str[0])
if args.pout is not None:
    phases.to_csv(args.pout,
                  index=False, header=False, sep=" ", float_format="%.9g")

# Write slopes to args.sout
slopes = pd.DataFrame(data=slopes)
slopes.insert(0, 'site', baselines.str[0])
if args.sout is not None:
    slopes.to_csv(args.sout,
                  index=False, header=False, sep=" ", float_format="%.9g")

# FIXME: write delay offsets to args.dout
if args.dout is not None:
    raise ValueError("The option \"-d\" is not implemented")

# TODO: write HOPS control file to args.cout
if args.cout is not None:
    raise ValueError("The option \"-c\" is not implemented")
