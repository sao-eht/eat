#!/usr/bin/env python
#
# Use ALMA to reference phase-cal phases and delay offsets
# 2017-11-22 Chi-kwan Chan (move from pipeline to EAT)
# 2017-12-28 CKC major update to simplify pipelining

from __future__ import print_function

import datetime, string
import pwd, os, sys
import argparse

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.cm     as cm

import pandas as pd
import numpy  as np

from eat.io   import hops, util
from eat.hops import util as hu

#------------------------------------------------------------------------------
# Logging
statline = "[{}] {}@{}:{}$ {}".format(
    datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
    pwd.getpwuid(os.getuid())[0], os.uname()[1], os.getcwd(),
    ' '.join(sys.argv))

#==============================================================================
# Helper functions

def unwrap(phi):
    """Unwrap an array of angles to avoid artificial jumps due to branching
    """
    for i in np.arange(len(phi)-1)+1:
        if   phi[i] - phi[i-1] >  180: phi[i:] -= 360
        elif phi[i] - phi[i-1] < -180: phi[i:] += 360
    return phi

def offset(phi):
    """Offset an array of angles (in degree) to the principle branch
    """
    while True:
        m = np.mean(phi)
        if   m >  180: phi -= 360
        elif m < -180: phi += 360
        else         : break
    return phi

def load(file):
    """Read an alist file and prepare phases phase-cal

    Read an alist file, apply filter to select the userful rows, and
    then access the corel (per-channel) phases for performing
    phase-cal.
    """
    a = util.noauto(hops.read_alist(file))

    # Apply row filtering
    a = a[a.baseline.str.contains("A")] # must contain ALMA
    a = a[(a.polarization == 'LL')|
          (a.polarization == 'RR')]
    a = a.reset_index(drop=True)
    util.add_path(a)

    # Access corel (per-channel) phases
    phases = None
    for i, f in a.path.iteritems():
        b = a.baseline[i]
        p = a.resid_phas[i] * np.pi / 180.0
        v = hu.pop210(f)
        l = len(v)
        if phases is None: # allocate after pop210() to get number of channels
            phases = np.zeros((len(a), l), dtype=np.float32)
        elif l != phases.shape[1]:
            print("WARNING: \"{}\" has {} less channel(s) than expected".
                  format(f, phases.shape[1] - l), file=sys.stderr)

        phases[i,:l] = offset(unwrap(np.angle(v * np.exp(-1j * p), deg=True)))

        if b[1] == "A": # need to swap baseline and negate phases
            a.baseline[i] = b[::-1]
            phases[i,:]   = -phases[i,:]
            print("WARNING: ALMA is not the reference", file=sys.stderr)

    # Construct and return final Pandas DataFrame
    chans = list(string.ascii_letters[:phases.shape[1]])
    cols  = ['polarization', 'baseline', 'quality', 'snr', 'resid_phas']
    return pd.concat([a[cols], pd.DataFrame(phases, columns=chans)], axis=1)

def qfit(y1, y2, y3):
    a  =       y1
    b  = (-3.0*y1 + 4.0*y2 - y3) / 2.0
    c  = (     y1 - 2.0*y2 + y3) / 2.0
    return a, b, c

def derivative(y, dx=1.0):
    return np.concatenate((np.reshape(y[:, 1 ] - y[:,  0], (-1,1)),
                               0.5 * (y[:, 2:] - y[:,:-2]),
                           np.reshape(y[:,-1 ] - y[:, -2], (-1,1))),
                          axis=1) / dx

def mkplot(baselines, phases, slopes, file):
    cs = cm.rainbow(np.linspace(0,1,len(baselines)))
    d  = np.array([-0.5,0.5])
    x  = np.arange(phases.shape[1])
    for i, b in baselines.iteritems():
        y = -phases[i,:]
        m = -slopes[i,:]
        plt.scatter(x, y, color=cs[i], label=b)
        for j in x:
            plt.plot(x[j]+d, y[j]+d*m[j], color=cs[i])
    plt.legend()
    if "." in file:
        plt.savefig(file)
    else:
        plt.show()

def output_csv(baselines, data, file):
    out = pd.DataFrame(data)
    out.insert(0, 'label', baselines)
    out.to_csv(file, index=False, header=False, sep=" ", float_format="%.9g")

def output_cf(baselines, phas_r, phas_l, delays, file):
    need_open_close = not hasattr(file, "write")

    sites = baselines.str[1]
    chans = string.ascii_letters[:delays.shape[1]]

    if need_open_close:
        f = open(file, "w")
    else:
        f = file

    f.write("* {}\n\n".format(statline))
    for i, s in sites.iteritems():
        f.write("""if station {}
  pc_phases_r {}
    {}
  pc_phases_l {}
    {}
  delay_offs  {}
    {}

""".format(s, chans, " ".join(["{:.6f}".format(p) for p in -phas_r[i,:]]),
              chans, " ".join(["{:.6f}".format(p) for p in -phas_l[i,:]]),
              chans, " ".join(["{:.6f}".format(p) for p in -delays[i,:]])))

    if need_open_close:
        f.close()

#==============================================================================
# Main code
#------------------------------------------------------------------------------
# Argument parsing and read input file
try:
    datadir = os.environ['DATADIR']
except:
    datadir = None

parser = argparse.ArgumentParser(
    description="Estimate phase-cal phases and delay offsets")
parser.add_argument("filename",
                    help="alist file")
parser.add_argument("-d", "--datadir", default=datadir,
                    help="use fringe files from this data directory")
parser.add_argument("-o", "--outfile", default=[sys.stdout], nargs="+",
                    help="output file name(s); "+
                         "if \"-c\" is used, only 1 file name is allowed; "+
                         "otherwise, at most 1 names can be used")
parser.add_argument("-c", "--controlcodes", default=False, action="store_true",
                    help="construct control codes rather than csv table")
parser.add_argument("-g", "--graph", default=None,
                    help="graphic output")
args = parser.parse_args()

if len(args.outfile) > 4:
    print("At most 4 output files are supported")
    exit(1)
elif args.controlcodes and len(args.outfile) != 1:
    print("Only 1 output file is supported when \"--controlcodes\" is set")
    exit(1)

#------------------------------------------------------------------------------
# Get data and perform phase cal
if args.datadir is not None:
    hu.set_datadir(args.datadir)

df    = load(args.filename)
nchan = string.ascii_letters.find(df.columns[-1]) + 1
chans = list(string.ascii_letters[:nchan])
cols  = ['baseline'] + chans

ll = df[df.polarization == 'LL']
rr = df[df.polarization == 'RR']

pcf = df.groupby('baseline')[cols].mean()
pcl = ll.groupby('baseline')[cols].mean()
pcr = rr.groupby('baseline')[cols].mean()

#------------------------------------------------------------------------------
# Pull out baselines and phases, use one-side and mid-point
# methods to esimate slopes
baselines = pd.Series(pcf.index.values)
phases    = pcf.values
slopes    = derivative(phases)

# Extrapolation for last channel
a, b, c = qfit(phases[:,-4], phases[:,-3], phases[:,-2])
phases[:,-1] = a + 3.0*b + 9.0*c # == a + b x +   c x**2 with x == 3
slopes[:,-1] =         b + 6.0*c # ==     b   + 2 c x    with x == 3

# Apply fitted slope (instead of one-side derivative) to edge channels
slopes[:,-2] = b + 4.0*c # == b   + 2 c x    with x == 2
a, b, c = qfit(phases[:,0], phases[:,1], phases[:,2])
slopes[:, 0] = b         # == b   + 2 c x    with x == 0

# Convert slopes to delay offsets
d_nu   = 58.59375e6 # hard wire separation between channels
delays = 1e9 * (slopes / 360.0) / d_nu # in nanosecond

#------------------------------------------------------------------------------
# Outputs
if args.controlcodes:
    output_cf(baselines, pcr.values, pcl.values, delays, args.outfile[0])
else:
    d = {'r': pcr.values,
         'l': pcl.values,
         'd': delays,
         's': slopes}
    if len(args.outfile) == 1:
        f = args.outfile[0]
        if hasattr(f, "write"):
            for k, v in d.items():
                output_csv(baselines, v, f)
        else:
            p, x = os.path.splitext(f)
            for k, v in d.items():
                output_csv(baselines, v, p+'_'+k+x)
    else:
        k = list("rlds")
        for i, f in enumerate(args.outfile):
            output_csv(baselines, d[k[i]], f)

if args.graph is not None:
    mkplot(baselines, pcf.values, slopes, args.graph)
